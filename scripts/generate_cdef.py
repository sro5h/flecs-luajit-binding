#!/usr/bin/env python3

import os
import json

from clang.cindex import *
from collections import OrderedDict
from textwrap import indent
from argparse import ArgumentParser
from pathlib import Path

def dump_decl(c_type, identifier, part_a, part_b, part_c):
    const = "const" if c_type.is_const_qualified() else ""

    if c_type.get_declaration().is_anonymous() and c_type.is_pod():
        return " ".join(filter(None, [part_a, dump_pod(c_type.get_declaration()), part_b, identifier, part_c]))

    if c_type.kind == TypeKind.TYPEDEF and \
       c_type.get_declaration().underlying_typedef_type.kind in { TypeKind.ELABORATED, TypeKind.ENUM, TypeKind.POINTER }:
        part_b = " ".join(filter(None, [const, part_b]))
        return dump_decl(c_type.get_declaration().underlying_typedef_type, identifier, part_a, part_b, part_c)

    if c_type.kind == TypeKind.FUNCTIONPROTO:
        args = ", ".join(dump_decl(a, "", "", "", "") for a in c_type.argument_types()) if c_type.argument_types() else "void"
        middle = " ".join(filter(None, [part_b, identifier, part_c]))
        return dump_decl(c_type.get_result(), f"({middle})({args})", "", "", "")

    if c_type.kind == TypeKind.POINTER:
        part_b = " ".join(filter(None, ["*", const, part_b]))
        return dump_decl(c_type.get_pointee(), identifier, part_a, part_b, part_c)

    if c_type.kind == TypeKind.CONSTANTARRAY:
        part_c = f"[{c_type.element_count}]" + part_c
        return dump_decl(c_type.element_type, identifier, part_a, part_b, part_c)

    return " ".join(filter(None, [part_a, c_type.spelling, part_b, identifier, part_c]))

def dump_pod(cursor, privatize = False):
    pod_type = "union" if cursor.kind == CursorKind.UNION_DECL else "struct"
    result = " ".join(filter(None, [pod_type, cursor.spelling, "{\n"]))

    for m in cursor.get_children():
        if m.kind == CursorKind.FIELD_DECL:
            identifier = f"_{m.spelling}" if privatize else m.spelling
            result += indent(dump_decl(m.type, identifier, "", "", "") + ";\n", "    ")

    result += "}"
    return result

def dump_enum(cursor):
    result = ""
    result += f"{cursor.type.spelling} {{\n"

    for v in cursor.get_children():
        result += f"    {v.spelling},\n"

    result += "}"
    return result

def dump_typedef(cursor):
    return f"typedef {dump_decl(cursor.underlying_typedef_type, cursor.spelling, '', '', '')}"

def dump_function(cursor):
    c_type = cursor.type
    args = ", ".join(dump_decl(a, "", "", "", "") for a in c_type.argument_types()) if c_type.argument_types() else "void"
    return f"{dump_decl(cursor.type.get_result(), '', '', '', '')} {cursor.spelling}({args})"

def dump_var(cursor):
    linkage = ""
    if cursor.linkage == LinkageKind.EXTERNAL:
        linkage = "extern"
    elif cursor.linkage == LinkageKind.INTERNAL:
        linkage = "static"

    return " ".join(filter(None, [linkage, dump_decl(cursor.type, cursor.spelling, "", "", "")]))


def dump(cursor, privatize):
    result = ""

    if cursor.kind == CursorKind.STRUCT_DECL:
        result += f"{dump_pod(cursor, privatize)};\n"
    elif cursor.kind == CursorKind.ENUM_DECL:
        result += f"{dump_enum(cursor)};\n"
    elif cursor.kind == CursorKind.TYPEDEF_DECL:
        result += f"{dump_typedef(cursor)};\n"
    elif cursor.kind == CursorKind.FUNCTION_DECL:
        result += f"{dump_function(cursor)};\n"
    elif cursor.kind == CursorKind.VAR_DECL:
        result += f"{dump_var(cursor)};\n"

    return result.strip()

def dump_unit(unit, symbols, path):
    symbols_dict = { 'Typedef': {}, 'Default': {} }
    result = f'/* Symbols from {path} {{{{{{ */\n'

    for c in unit.cursor.get_children():
        if c.kind == CursorKind.TYPEDEF_DECL:
            symbols_dict['Typedef'][c.spelling] = c
        else:
            symbols_dict['Default'][c.spelling] = c

    for s in symbols:
        if s.get('comment') is not None:
            continue
        privatize = s.get('privatize', False)
        result += dump(symbols_dict[s['kind']][s['name']], privatize) + '\n'

    result +=  '/* }}} */\n'
    return result.strip()

if __name__ == '__main__':
    parser = ArgumentParser(description = 'Generate cdef lua files')
    parser.add_argument('-i', type = str, nargs = '+', required = True, help = 'Input files')
    parser.add_argument('-o', type = str, nargs = '?', help = 'Output file')
    args = parser.parse_args()
    assert(args)

    result  = '-- This file is automatically generated by generate_cdef.py\n'
    result += 'return [[\n'

    o_path = Path(args.o) if args.o is not None else Path('')

    for i in args.i:
        i_path = Path(i)

        with i_path.open() as i_file:
            i_json = json.load(i_file)

            for f in i_json['files']:
                c_args = [ '-I' + (i_path.parent / d).as_posix() for d in f.get('include_dirs', []) ]
                f_path = i_path.parent / f['path']
                unit = Index.create().parse(f_path, c_args)

                c_path = os.path.commonpath([ o_path.resolve(), f_path.resolve() ])
                result += dump_unit(unit, f['symbols'], f_path.resolve().relative_to(c_path)) + "\n"

    result += ']]\n'

    if args.o is None:
        print(result)
    else:
        o_path.parent.mkdir(parents = True, exist_ok = True)
        o_path.write_text(result)
